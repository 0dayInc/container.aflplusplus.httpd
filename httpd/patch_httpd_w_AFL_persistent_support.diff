--- server/main.c	2020-09-02 09:24:31.000000000 -0600
+++ server/main.AFL++.c	2020-09-03 20:01:08.000000000 -0600
@@ -14,6 +14,31 @@
  * limitations under the License.
  */
 
+// AFL++ SNIP
+#include <sched.h>
+#include <linux/sched.h>
+#include <arpa/inet.h>
+#include <errno.h>
+#include <net/if.h>
+#include <net/route.h>
+#include <netinet/ip6.h>
+#include <netinet/tcp.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <strings.h>
+#include <sys/ioctl.h>
+#include <sys/resource.h>
+#include <sys/socket.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <unistd.h>
+
+__AFL_FUZZ_INIT();
+// AFL++ EOS
+
 #include "apr.h"
 #include "apr_strings.h"
 #include "apr_getopt.h"
@@ -482,15 +507,147 @@
     ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                  "  -X                 : debug mode (only one worker, do not detach)");
 
-    destroy_and_exit_process(process, 1);
+// AFL++ SNIP
+    destroy_and_exit_process(process, 0);
+// AFL++ EOS
 }
 
+// AFL++ SNIP
+static void INIT_AFL_MUTATION_SESSION(process_rec *process)
+{
+  //int BUFSIZE=1024*1024;
+  //char buf[BUFSIZE+1];
+
+  // DEFINE __AFL_LOOP() MUTATION ITERATIONS
+  // This may be waaaaay too low but hey let's give it a go...
+  //int iterations = 10;
+  // Recommended Default (At least initially)
+  int iterations = 1000;
+  //int iterations = 3000;
+  // This may be waaaaay too high but hey let's give it a go...
+  //int iterations = 300000;
+  // This is the max number of mutation iterations 
+  // may be used / loop (if 100% stability is reached)
+  //int iterations = 2147483647;
+
+  // Init Mutated Payload Vars
+  //ssize_t len;
+  //unsigned char *buf;
+
+  //printf("[+]Deferring Initialization for Speed Boost...\n");
+  //__AFL_INIT();
+  unsigned char *buf = __AFL_FUZZ_TESTCASE_BUF;
+  printf("[+] ENTERING __AFL_LOOP(%d)...\n", iterations);
+  while ( __AFL_LOOP(iterations) ){
+    unsigned int len = __AFL_FUZZ_TESTCASE_LEN;
+
+    printf("=> memset len to buf %d\n", len);
+    memset(buf, 0, len);
+    size_t read_bytes = read(0, buf, len);
+    buf[len-2] = '\r';
+    buf[len-1] = '\n';
+    buf[len] = '\0';
+
+    printf("=> init sockfd\n");
+    int sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
+    if (sockfd == -1) {
+      printf("[!] sockfd error!\n");
+      perror("socket");
+      //_exit(1);
+      //exit(1);
+      //pthread_exit((void *)1);
+      destroy_and_exit_process(process, 1);
+    }
+
+    printf("=> init setsockopt\n");
+    int sz = (1024 * 1024);
+    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDBUF, &sz, sizeof(sz)) == -1) {
+      printf("[!] setsockopt error!\n");
+      perror("setsockopt");
+      //exit(1);
+      //pthread_exit((void *)1);
+      destroy_and_exit_process(process, 1);
+    }
+
+    printf("=> connecting to tcp port 80\n", buf);
+    struct sockaddr_in saddr;
+    saddr.sin_family = AF_INET;
+    saddr.sin_port = htons(80);
+    saddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+    if (connect(sockfd, &saddr, sizeof(saddr)) == -1) {
+      printf("[!] Failed to connect do sockfd!\n");
+      continue;
+    }
+
+    printf("=> sending buf %s\n", buf);
+    if (send(sockfd, buf, read_bytes, MSG_NOSIGNAL) != read_bytes) {
+      printf("[!] Failed to send payload over sockfd!\n");
+      //exit(1);
+      //pthread_exit((void *)1);
+      destroy_and_exit_process(process, 1);
+    }
+
+    printf("=> buf sent %s\n", &buf);
+
+    if (shutdown(sockfd, SHUT_WR) == -1) {
+      perror("[!] failed to shutdown sockfd!\n");
+      //exit(1);
+      //pthread_exit((void *)1);
+      destroy_and_exit_process(process, 1);
+    }
+
+    char b[1024 * 1024];
+    while (recv(sockfd, b, sizeof(b), MSG_WAITALL) > 0) ;
+      printf("=> received from sockfd %s\n", b);
+
+      printf("=> closing sockfd\n");
+      close(sockfd);
+      printf("=> successfully closed sockfd\n");
+  }
+  printf("[+] EXITING __AFL_LOOP(%d)\n", iterations);
+  //printf("[*]: EXITING AFL++ mutation thread...\n");
+  printf("[*]: EXITING AFL++ mutation thread && parent process gracefully...\n");
+  //pthread_exit((void *)0);
+  destroy_and_exit_process(process, 0);
+}
+
+static void INIT_AFL_THREAD(process_rec *process)
+{
+    pthread_t t;
+    pthread_attr_t attr;
+    void *tret; // Need a pthread_join to take advantage of thread return codes
+
+    pthread_attr_init(&attr);
+    pthread_attr_setstacksize(&attr, 1024 * 1024 * 8);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+
+    printf("[*]: CREATING AFL++ mutation thread...\n");
+    int err = pthread_create(&t, &attr, INIT_AFL_MUTATION_SESSION, process);
+    if (err != 0) {
+      printf("[!] %d: Unable to CREATE AFL++ mutation thread.\n", err);
+      printf("[!] Tearing down parent process gracefully...\n");
+      destroy_and_exit_process(process, err);
+    }
+
+    //err = pthread_join(t, &tret);
+    //if (err == 0) {
+    //  printf("Tearing down parent process gracefully...\n");
+    //  destroy_and_exit_process(process, 0);
+    //} else {
+    //  printf("[!] %d: Unable to JOIN AFL++ mutation thread.\n", err);
+    //  printf("[!] Tearing down parent process gracefully...\n");
+    //  destroy_and_exit_process(process, err);
+    //}
+}
+// AFL++ EOS
+
 #ifdef HFND_FUZZING_ENTRY_FUNCTION
  HFND_FUZZING_ENTRY_FUNCTION(int argc, const char *const *argv)
 #else
  int main(int argc, const char *const *argv)
 #endif
 {
+
     char c;
     int showcompile = 0, showdirectives = 0;
     const char *confname = SERVER_CONFIG_FILE;
@@ -498,6 +655,7 @@
     const char *temp_error_log = NULL;
     const char *error;
     process_rec *process;
+
     apr_pool_t *pconf;
     apr_pool_t *plog; /* Pool of log streams, reset _after_ each read of conf */
     apr_pool_t *ptemp; /* Pool for temporary config stuff, reset often */
@@ -512,6 +670,18 @@
     AP_MONCONTROL(0); /* turn off profiling of startup */
 
     process = init_process(&argc, &argv);
+    // AFL++ SNIP
+    if (getenv("CRASH_TEST") == NULL) {
+#ifdef __AFL_HAVE_MANUAL_CONTROL
+      printf("[*] Deferring Initialization for Speed Boost...\n");
+      __AFL_INIT();
+      INIT_AFL_THREAD(process);
+#endif
+    } else {
+      printf("[!] Crash Test Mode Initialized:\n");
+    }
+    // AFL++ EOS
+
     ap_pglobal = process->pool;
     pconf = process->pconf;
     ap_server_argv0 = process->short_name;
@@ -742,7 +912,11 @@
 
     /* If our config failed, deal with that here. */
     if (rv != OK) {
-        destroy_and_exit_process(process, 1);
+        // AFL++ SNIP
+        printf("[!] Config failed...\n");
+        destroy_and_exit_process(process, 0);
+        // AFL++ EOS        
+        //destroy_and_exit_process(process, 1);
     }
 
     signal_server = APR_RETRIEVE_OPTIONAL_FN(ap_signal_server);
@@ -750,6 +924,9 @@
         int exit_status;
 
         if (signal_server(&exit_status, pconf) != 0) {
+            // AFL++ SNIP
+            printf("[-] Server signaled out\n");
+            // AFL++ EOS
             destroy_and_exit_process(process, exit_status);
         }
     }
